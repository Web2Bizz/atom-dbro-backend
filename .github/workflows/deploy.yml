name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  IMAGE_NAME: atom-dbro-backend

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      - name: Verify image was built
        run: |
          if ! docker images | grep -q "${{ env.IMAGE_NAME }}.*latest"; then
            echo "‚ùå ERROR: Docker image was not built successfully"
            exit 1
          fi
          echo "‚úÖ Docker image built successfully: ${{ env.IMAGE_NAME }}:latest"
          docker images | grep "${{ env.IMAGE_NAME }}"

  export:
    name: Export Docker Image
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (for export)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      - name: Export Docker image to tar.gz
        run: |
          echo "üì¶ Exporting Docker image to tar.gz..."
          docker save ${{ env.IMAGE_NAME }}:latest | gzip > image.tar.gz
          
          echo "üìä Image file info:"
          ls -lh image.tar.gz
          IMAGE_SIZE=$(du -h image.tar.gz | cut -f1)
          echo "Image size: $IMAGE_SIZE"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω –∏ –Ω–µ –ø—É—Å—Ç–æ–π
          if [ ! -f image.tar.gz ] || [ ! -s image.tar.gz ]; then
            echo "‚ùå ERROR: Failed to export Docker image"
            exit 1
          fi
          
          echo "‚úÖ Docker image exported successfully"

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar.gz
          retention-days: 1

  transfer:
    name: Transfer Image to Server
    needs: export
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Validate SSH connection
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "echo 'SSH connection successful' && hostname"

      - name: Transfer Docker image to server
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          
          echo "üì¶ Transferring Docker image to server..."
          echo "üìä Image file size: $(du -h image.tar.gz | cut -f1)"
          
          # –ü–µ—Ä–µ–¥–∞–µ–º –æ–±—Ä–∞–∑ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
          scp -o StrictHostKeyChecking=no -P "$SSH_PORT" image.tar.gz ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:/tmp/
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "if [ -f /tmp/image.tar.gz ]; then echo '‚úÖ Image file transferred successfully'; ls -lh /tmp/image.tar.gz; else echo '‚ùå ERROR: Image file not found on server'; exit 1; fi"
          
          echo "‚úÖ Docker image transferred successfully"
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}

  deploy:
    name: Deploy Application
    needs: transfer
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Deploy application
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'REMOTE_SCRIPT'
            set -e
            
            IMAGE_NAME="atom-dbro-backend"
            PROJECT_DIR="$PROJECT_DIR_VALUE"
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
            cd "$PROJECT_DIR" || exit 1
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–∑ –≤ Docker
            echo "üì• Importing Docker image from tar.gz..."
            if [ ! -f /tmp/image.tar.gz ]; then
              echo "‚ùå ERROR: Image file not found: /tmp/image.tar.gz"
              exit 1
            fi
            
            echo "üìä Image file size: $(du -h /tmp/image.tar.gz | cut -f1)"
            docker load -i /tmp/image.tar.gz
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ –∑–∞–≥—Ä—É–∂–µ–Ω
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Failed to import Docker image"
              exit 1
            fi
            
            echo "‚úÖ Docker image imported successfully"
            
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            rm -f /tmp/image.tar.gz
            echo "üßπ Cleaned up temporary image file"
            
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º
            echo "üßπ Removing old image versions (if any)..."
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || echo "No old image versions to remove"
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ç–µ–π Docker (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
            echo "üåê Ensuring Docker networks exist..."
            docker network create atom-external-network 2>/dev/null || echo "Network atom-external-network already exists"
            docker network create atom-internal-network 2>/dev/null || echo "Network atom-internal-network already exists"
            
            # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
            echo "üõë Stopping old containers..."
            docker-compose -f docker-compose.prod.yml down || echo "No running containers to stop"
            
            # –ó–∞–ø—É—Å–∫ –Ω–æ–≤—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
            echo "‚ñ∂Ô∏è Starting new containers..."
            docker-compose -f docker-compose.prod.yml up -d
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            echo "‚è≥ Waiting for application container to be ready..."
            sleep 10
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω
            if ! docker ps | grep -q "atom-dbro-app"; then
              echo "‚ùå Application container failed to start"
              echo "üìã Container logs:"
              docker logs atom-dbro-app --tail 50 || true
              exit 1
            fi
            
            # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            echo "üóÑÔ∏è Running database migrations..."
            MAX_MIGRATION_ATTEMPTS=3
            MIGRATION_ATTEMPT=0
            
            while [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; do
              if docker exec atom-dbro-app npm run db:migrate; then
                echo "‚úÖ Database migrations completed successfully"
                break
              else
                MIGRATION_ATTEMPT=$((MIGRATION_ATTEMPT + 1))
                if [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; then
                  echo "‚ö†Ô∏è Migration attempt $MIGRATION_ATTEMPT failed, retrying in 5 seconds..."
                  sleep 5
                else
                  echo "‚ùå Database migrations failed after $MAX_MIGRATION_ATTEMPTS attempts"
                  docker logs atom-dbro-app --tail 50
                  exit 1
                fi
              fi
            done
            
            # Health check –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
            echo "üè• Performing health check..."
            MAX_HEALTH_CHECK_ATTEMPTS=30
            HEALTH_CHECK_ATTEMPT=0
            HEALTH_CHECK_SUCCESS=false
            
            while [ $HEALTH_CHECK_ATTEMPT -lt $MAX_HEALTH_CHECK_ATTEMPTS ]; do
              if curl -f http://localhost:3000/api > /dev/null 2>&1; then
                HEALTH_CHECK_SUCCESS=true
                break
              fi
              HEALTH_CHECK_ATTEMPT=$((HEALTH_CHECK_ATTEMPT + 1))
              if [ $HEALTH_CHECK_ATTEMPT -lt $MAX_HEALTH_CHECK_ATTEMPTS ]; then
                echo "Health check attempt $HEALTH_CHECK_ATTEMPT/$MAX_HEALTH_CHECK_ATTEMPTS failed, retrying in 2 seconds..."
                sleep 2
              fi
            done
            
            if [ "$HEALTH_CHECK_SUCCESS" = true ]; then
              echo "‚úÖ Application is healthy and responding!"
              echo "üåê Application is available at: http://localhost:3000"
              echo "üìö Swagger docs: http://localhost:3000/api"
            else
              echo "‚ùå Health check failed after $MAX_HEALTH_CHECK_ATTEMPTS attempts"
              docker logs atom-dbro-app --tail 100
              exit 1
            fi
            
            # –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö Docker —Ä–µ—Å—É—Ä—Å–æ–≤ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
            echo "üßπ Cleaning up unused Docker resources..."
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1 || true
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || true
            
            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ volumes –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            # –£–¥–∞–ª—è–µ—Ç: –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã, build cache, —Å–µ—Ç–∏
            docker system prune -a -f || echo "‚ö†Ô∏è Warning: Some resources could not be cleaned up"
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1 || true
            
            echo "‚úÖ Deployment completed successfully!"
          REMOTE_SCRIPT
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          PROJECT_DIR_VALUE: ${{ secrets.DEPLOY_PROJECT_PATH }}

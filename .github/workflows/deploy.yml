name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  IMAGE_NAME: ${{ secrets.DOCKER_IMAGE_NAME || 'atom-dbro-backend' }}

jobs:
  build:
    name: Build and Export Docker Image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine build target
        id: build_target
        shell: bash
        run: |
          if [ "$HAS_BUILD_HOST" = "true" ] && [ "$HAS_BUILD_USER" = "true" ] && [ "$HAS_BUILD_KEY" = "true" ]; then
            echo "use_remote=true" >> "$GITHUB_OUTPUT"
            echo "üõ∞Ô∏è  Remote build server configuration detected. Using remote builder."
          else
            echo "use_remote=false" >> "$GITHUB_OUTPUT"
            echo "üèóÔ∏è  Remote build server not configured. Using GitHub runner for build."
          fi
        env:
          HAS_BUILD_HOST: ${{ format('{0}', secrets.BUILD_SERVER_HOST != '') }}
          HAS_BUILD_USER: ${{ format('{0}', secrets.BUILD_SERVER_USER != '') }}
          HAS_BUILD_KEY: ${{ format('{0}', secrets.BUILD_SERVER_SSH_KEY != '') }}

      - name: Set up SSH for build server
        if: steps.build_target.outputs.use_remote == 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.BUILD_SERVER_SSH_KEY }}

      - name: Validate build server connection
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
        run: |
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            "echo 'SSH connection to build server successful'; hostname"

      - name: Setup Git SSH key on build server (if provided)
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          BUILD_SERVER_GIT_SSH_KEY: ${{ secrets.BUILD_SERVER_GIT_SSH_KEY }}
          HAS_GIT_SSH_KEY: ${{ secrets.BUILD_SERVER_GIT_SSH_KEY != '' }}
        run: |
          if [ "$HAS_GIT_SSH_KEY" != "true" ]; then
            echo "‚ÑπÔ∏è  BUILD_SERVER_GIT_SSH_KEY not provided, skipping Git SSH setup"
            exit 0
          fi
          
          echo "üîë Setting up Git SSH key on build server..."
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            BUILD_SERVER_GIT_SSH_KEY="$BUILD_SERVER_GIT_SSH_KEY" \
            'bash -s' <<'REMOTE_SCRIPT'
          set -euo pipefail
          
          # –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è SSH –∫–ª—é—á–µ–π
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # –°–æ—Ö—Ä–∞–Ω—è–µ–º Git SSH –∫–ª—é—á
          echo "$BUILD_SERVER_GIT_SSH_KEY" > ~/.ssh/github_deploy_key
          chmod 600 ~/.ssh/github_deploy_key
          
          # –î–æ–±–∞–≤–ª—è–µ–º github.com –≤ known_hosts
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Git –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–≥–æ –∫–ª—é—á–∞
          cat > ~/.ssh/config <<'SSHCONFIG'
          Host github.com
              HostName github.com
              User git
              IdentityFile ~/.ssh/github_deploy_key
              StrictHostKeyChecking no
          SSHCONFIG
          chmod 600 ~/.ssh/config
          
          echo "‚úÖ Git SSH key configured"
          REMOTE_SCRIPT

      - name: Sync source to build server
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_PROJECT_PATH: ${{ secrets.BUILD_SERVER_PROJECT_PATH || '/tmp/atom-dbro-build' }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF: ${{ github.ref }}
          USE_GIT_SSH: ${{ secrets.BUILD_SERVER_GIT_SSH_KEY != '' && 'true' || 'false' }}
          GITHUB_TOKEN: ${{ secrets.BUILD_SERVER_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            GITHUB_REPOSITORY="$GITHUB_REPOSITORY" \
            GITHUB_SHA="$GITHUB_SHA" \
            GITHUB_REF="$GITHUB_REF" \
            BUILD_SERVER_PROJECT_PATH="$BUILD_SERVER_PROJECT_PATH" \
            USE_GIT_SSH="$USE_GIT_SSH" \
            'bash -s' <<'REMOTE_SCRIPT'
          set -euo pipefail
          
          echo "üì¶ Syncing repository to build server..."
          echo "Repository: $GITHUB_REPOSITORY"
          echo "Commit: $GITHUB_SHA"
          echo "Ref: $GITHUB_REF"
          echo "Path: $BUILD_SERVER_PROJECT_PATH"
          echo "Use SSH: $USE_GIT_SSH"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ git
          if ! command -v git &> /dev/null; then
            echo "‚ùå ERROR: git is not installed on build server"
            echo "Please install git: sudo apt-get install git (Ubuntu/Debian) or sudo yum install git (CentOS/RHEL)"
            exit 1
          fi
          
          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º URL —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è (SSH –∏–ª–∏ HTTPS)
          if [ "$USE_GIT_SSH" = "true" ]; then
            REPO_URL="git@github.com:$GITHUB_REPOSITORY.git"
            echo "üîë Using SSH for git operations"
          else
            REPO_URL="https://github.com/$GITHUB_REPOSITORY.git"
            echo "üåê Using HTTPS for git operations"
          fi
          
          # –ï—Å–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ —ç—Ç–æ git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
          if [ -d "$BUILD_SERVER_PROJECT_PATH/.git" ]; then
            echo "üìÇ Repository exists, updating..."
            cd "$BUILD_SERVER_PROJECT_PATH"
            
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ª—é–±—ã–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
            git reset --hard
            git clean -fdx
            
            # –û–±–Ω–æ–≤–ª—è–µ–º remote URL –Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏–∑–º–µ–Ω–∏–ª—Å—è
            git remote set-url origin "$REPO_URL"
            
            # Fetch –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
            git fetch origin
            
            # Checkout –Ω—É–∂–Ω–æ–≥–æ –∫–æ–º–º–∏—Ç–∞
            git checkout -f "$GITHUB_SHA"
          else
            echo "üì• Cloning repository..."
            # –£–¥–∞–ª—è–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–æ –Ω–µ git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
            rm -rf "$BUILD_SERVER_PROJECT_PATH"
            
            # –ö–ª–æ–Ω–∏—Ä—É–µ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
            git clone "$REPO_URL" "$BUILD_SERVER_PROJECT_PATH"
            cd "$BUILD_SERVER_PROJECT_PATH"
            
            # Checkout –Ω—É–∂–Ω–æ–≥–æ –∫–æ–º–º–∏—Ç–∞
            git checkout "$GITHUB_SHA"
          fi
          
          echo "‚úÖ Repository synced successfully"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "üìÅ Project directory contents:"
          ls -la
          REMOTE_SCRIPT

      - name: Build Docker image on build server
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_PROJECT_PATH: ${{ secrets.BUILD_SERVER_PROJECT_PATH || '/tmp/atom-dbro-build' }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          REMOTE_IMAGE_PATH: /tmp/atom-dbro-image.tar.gz
          ENABLE_BUILD_CACHE: ${{ secrets.ENABLE_BUILD_CACHE || 'false' }}
        run: |
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" \
            "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            BUILD_SERVER_PROJECT_PATH="$BUILD_SERVER_PROJECT_PATH" \
            IMAGE_NAME="$IMAGE_NAME" \
            REMOTE_IMAGE_PATH="$REMOTE_IMAGE_PATH" \
            ENABLE_BUILD_CACHE="$ENABLE_BUILD_CACHE" \
            'bash -s' <<'REMOTE_SCRIPT'
          set -euo pipefail
          cd "$BUILD_SERVER_PROJECT_PATH"
          echo "üì¶ Building Docker image $IMAGE_NAME:latest on remote server..."
          
          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–ª–∞–≥–∏ –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
          if [ "$ENABLE_BUILD_CACHE" = "true" ]; then
            echo "‚úÖ Build cache enabled"
            NO_CACHE_FLAG=""
          else
            echo "üö´ Build cache disabled"
            NO_CACHE_FLAG="--no-cache"
          fi
          
          if docker buildx version >/dev/null 2>&1; then
            docker buildx build --load -t "$IMAGE_NAME:latest" $NO_CACHE_FLAG -f Dockerfile .
          else
            echo "‚ÑπÔ∏è  docker buildx not available, using docker build."
            docker build -t "$IMAGE_NAME:latest" $NO_CACHE_FLAG -f Dockerfile .
          fi
          echo "üì§ Exporting Docker image archive to $REMOTE_IMAGE_PATH"
          docker save "$IMAGE_NAME:latest" | gzip > "$REMOTE_IMAGE_PATH"
          ls -lh "$REMOTE_IMAGE_PATH"
          REMOTE_SCRIPT

      - name: Download Docker image artifact from build server
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          REMOTE_IMAGE_PATH: /tmp/atom-dbro-image.tar.gz
        run: |
          scp -o StrictHostKeyChecking=no -P "$BUILD_SERVER_SSH_PORT" \
            "$BUILD_SERVER_USER@$BUILD_SERVER_HOST:$REMOTE_IMAGE_PATH" ./image.tar.gz

      - name: Clean up remote build artifacts
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          REMOTE_IMAGE_PATH: /tmp/atom-dbro-image.tar.gz
        run: |
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" \
            "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            "rm -f '$REMOTE_IMAGE_PATH'"

      - name: Validate remote build artifact
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        run: |
          if [ ! -f image.tar.gz ] || [ ! -s image.tar.gz ]; then
            echo "‚ùå ERROR: image.tar.gz was not downloaded from build server or is empty"
            exit 1
          fi
          echo "‚úÖ Remote Docker image artifact ready"
          ls -lh image.tar.gz

      - name: Set up Docker Buildx
        if: steps.build_target.outputs.use_remote != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        if: steps.build_target.outputs.use_remote != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:latest
          no-cache: ${{ secrets.ENABLE_BUILD_CACHE != 'true' }}
          cache-from: ${{ secrets.ENABLE_BUILD_CACHE == 'true' && 'type=gha' || '' }}
          cache-to: ${{ secrets.ENABLE_BUILD_CACHE == 'true' && 'type=gha,mode=max' || '' }}

      - name: Verify image was built
        if: steps.build_target.outputs.use_remote != 'true'
        run: |
          if ! docker images | grep -q "${{ env.IMAGE_NAME }}.*latest"; then
            echo "‚ùå ERROR: Docker image was not built successfully"
            exit 1
          fi
          echo "‚úÖ Docker image built successfully: ${{ env.IMAGE_NAME }}:latest"
          docker images | grep "${{ env.IMAGE_NAME }}"

      - name: Export Docker image to tar.gz
        if: steps.build_target.outputs.use_remote != 'true'
        run: |
          echo "üì¶ Exporting Docker image to tar.gz..."
          docker save ${{ env.IMAGE_NAME }}:latest | gzip > image.tar.gz
          
          echo "üìä Image file info:"
          ls -lh image.tar.gz
          IMAGE_SIZE=$(du -h image.tar.gz | cut -f1)
          echo "Image size: $IMAGE_SIZE"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω –∏ –Ω–µ –ø—É—Å—Ç–æ–π
          if [ ! -f image.tar.gz ] || [ ! -s image.tar.gz ]; then
            echo "‚ùå ERROR: Failed to export Docker image"
            exit 1
          fi
          
          echo "‚úÖ Docker image exported successfully"

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar.gz
          retention-days: 1

  transfer:
    name: Transfer Image to Server
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Validate SSH connection
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "echo 'SSH connection successful' && hostname"

      - name: Transfer Docker image to server
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          
          echo "üì¶ Transferring Docker image to server..."
          echo "üìä Image file size: $(du -h image.tar.gz | cut -f1)"
          
          # –ü–µ—Ä–µ–¥–∞–µ–º –æ–±—Ä–∞–∑ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
          scp -o StrictHostKeyChecking=no -P "$SSH_PORT" image.tar.gz ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:/tmp/
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "if [ -f /tmp/image.tar.gz ]; then echo '‚úÖ Image file transferred successfully'; ls -lh /tmp/image.tar.gz; else echo '‚ùå ERROR: Image file not found on server'; exit 1; fi"
          
          echo "‚úÖ Docker image transferred successfully"
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}

  deploy:
    name: Deploy Application
    needs: transfer
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Deploy application
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "export PROJECT_DIR_VALUE='$PROJECT_DIR_VALUE' CONTAINER_NAME='$CONTAINER_NAME' IMAGE_NAME='$IMAGE_NAME' SERVICE_NAME='$SERVICE_NAME' COMPOSE_PROJECT_NAME='$COMPOSE_PROJECT_NAME' RUN_MIGRATIONS='$RUN_MIGRATIONS'; bash -s" << 'REMOTE_SCRIPT'
            set -e
            
            IMAGE_NAME="${IMAGE_NAME:-atom-dbro-backend}"
            PROJECT_DIR="$PROJECT_DIR_VALUE"
            CONTAINER_NAME="${CONTAINER_NAME:-atom-dbro-app}"
            SERVICE_NAME="${SERVICE_NAME:-app}"
            COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-}"
            RUN_MIGRATIONS="${RUN_MIGRATIONS:-false}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è PROJECT_DIR —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ùå ERROR: PROJECT_DIR is not set"
              exit 1
            fi
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
            echo "üìÅ Changing to project directory: $PROJECT_DIR"
            cd "$PROJECT_DIR" || {
              echo "‚ùå ERROR: Failed to change to project directory: $PROJECT_DIR"
              exit 1
            }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found in $PROJECT_DIR"
              echo "Current directory: $(pwd)"
              echo "Files in directory:"
              ls -la || true
              exit 1
            fi
            
            echo "‚úÖ Found docker-compose.yml in $(pwd)"
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–∑ –≤ Docker
            echo "üì• Importing Docker image from tar.gz..."
            if [ ! -f /tmp/image.tar.gz ]; then
              echo "‚ùå ERROR: Image file not found: /tmp/image.tar.gz"
              exit 1
            fi
            
            echo "üìä Image file size: $(du -h /tmp/image.tar.gz | cut -f1)"
            docker load -i /tmp/image.tar.gz
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ –∑–∞–≥—Ä—É–∂–µ–Ω
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Failed to import Docker image"
              exit 1
            fi
            
            echo "‚úÖ Docker image imported successfully"
            
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            rm -f /tmp/image.tar.gz
            echo "üßπ Cleaned up temporary image file"
            
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º
            echo "üßπ Removing old image versions (if any)..."
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || echo "No old image versions to remove"
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ç–µ–π Docker (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
            echo "üåê Ensuring Docker networks exist..."
            docker network create atom-external-network 2>/dev/null || echo "Network atom-external-network already exists"
            docker network create atom-internal-network 2>/dev/null || echo "Network atom-internal-network already exists"
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            echo "üîÑ Restarting application container with new image..."
            echo "Working directory: $(pwd)"
            echo "Container name: $CONTAINER_NAME"
            echo "Service name: $SERVICE_NAME"
            echo "Docker image: $IMAGE_NAME:latest"
            
            # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –º—ã –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if [ "$(pwd)" != "$PROJECT_DIR" ]; then
              echo "‚ö†Ô∏è Warning: Not in project directory, changing to $PROJECT_DIR"
              cd "$PROJECT_DIR" || exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            COMPOSE_FILE="$PROJECT_DIR/docker-compose.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found at $COMPOSE_FILE"
              exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å
            if ! grep -q "^  $SERVICE_NAME:" "$COMPOSE_FILE"; then
              echo "‚ùå ERROR: Service '$SERVICE_NAME' not found in docker-compose.yml"
              echo "Available services:"
              grep -E "^  [a-zA-Z-]+:" "$COMPOSE_FILE" || echo "No services found"
              exit 1
            fi
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è docker-compose
            export DOCKER_IMAGE="$IMAGE_NAME:latest"
            echo "‚úÖ DOCKER_IMAGE environment variable set to: $DOCKER_IMAGE"
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫) –¥–ª—è docker-compose, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              export COMPOSE_PROJECT_NAME="$COMPOSE_PROJECT_NAME"
              echo "‚úÖ COMPOSE_PROJECT_NAME set to: $COMPOSE_PROJECT_NAME"
            else
              echo "‚ÑπÔ∏è COMPOSE_PROJECT_NAME not set, using default (directory name)"
            fi
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
            if docker ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "üõë Stopping existing container: $CONTAINER_NAME"
              docker stop "$CONTAINER_NAME" 2>/dev/null || true
              echo "üóëÔ∏è Removing existing container: $CONTAINER_NAME"
              docker rm "$CONTAINER_NAME" 2>/dev/null || true
            else
              echo "‚ÑπÔ∏è Container $CONTAINER_NAME does not exist, will be created"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Docker image $IMAGE_NAME:latest not found"
              echo "Available images:"
              docker images | head -10
              exit 1
            fi
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            # --force-recreate: –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å
            # --no-deps: –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            # --pull never: –Ω–µ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–∫–∞—á–∞—Ç—å –æ–±—Ä–∞–∑ (–æ–Ω —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω)
            # -p –∏–ª–∏ --project-name: —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫)
            echo "‚ñ∂Ô∏è Starting service '$SERVICE_NAME' with docker compose..."
            
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              echo "Command: docker compose -f '$COMPOSE_FILE' -p '$COMPOSE_PROJECT_NAME' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" -p "$COMPOSE_PROJECT_NAME" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            else
              echo "Command: docker compose -f '$COMPOSE_FILE' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—Å—Ç–∏–ª—Å—è
            if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "‚ùå ERROR: Container $CONTAINER_NAME failed to start"
              echo "Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              exit 1
            fi
            
            echo "‚úÖ Container $CONTAINER_NAME started successfully"
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            echo "‚è≥ Waiting for application container to be ready..."
            MAX_CONTAINER_WAIT_ATTEMPTS=30
            CONTAINER_WAIT_ATTEMPT=0
            CONTAINER_READY=false
            
            while [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
              if docker ps | grep -q "$CONTAINER_NAME" && docker exec "$CONTAINER_NAME" echo "Container is ready" > /dev/null 2>&1; then
                CONTAINER_READY=true
                echo "‚úÖ Container is ready and accepting commands"
                break
              fi
              CONTAINER_WAIT_ATTEMPT=$((CONTAINER_WAIT_ATTEMPT + 1))
              if [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; then
                echo "Waiting for container to be ready... ($CONTAINER_WAIT_ATTEMPT/$MAX_CONTAINER_WAIT_ATTEMPTS)"
                sleep 2
              fi
            done
            
            if [ "$CONTAINER_READY" != true ]; then
              echo "‚ùå Application container failed to start or is not ready"
              echo "üìã Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              echo "üìã Container logs:"
              docker logs "$CONTAINER_NAME" --tail 50 || true
              exit 1
            fi
            
            # –î–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é –≤—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—ã–π –∑–∞–ø—É—Å–∫
            echo "‚è≥ Waiting for application to fully start (10 seconds)..."
            sleep 10
            
            # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
            if [ "$RUN_MIGRATIONS" = "true" ]; then
              echo "üóÑÔ∏è Running database migrations..."
              MAX_MIGRATION_ATTEMPTS=3
              MIGRATION_ATTEMPT=0
              MIGRATION_SUCCESS=false
              
              while [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; do
                # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –º–∏–≥—Ä–∞—Ü–∏–π
                # –û–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —É–∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–µ –º–∏–≥—Ä–∞—Ü–∏–∏ –∏ –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–µ–Ω
                if docker exec "$CONTAINER_NAME" npm run db:apply-all 2>&1; then
                  MIGRATION_SUCCESS=true
                  echo "‚úÖ Database migrations completed successfully"
                  break
                else
                  MIGRATION_ATTEMPT=$((MIGRATION_ATTEMPT + 1))
                  if [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; then
                    echo "‚ö†Ô∏è Migration attempt $MIGRATION_ATTEMPT failed, retrying in 5 seconds..."
                    echo "üìã Recent container logs:"
                    docker logs "$CONTAINER_NAME" --tail 20 2>&1 | tail -5 || true
                    sleep 5
                  else
                    echo "‚ö†Ô∏è Custom migration script failed after $MAX_MIGRATION_ATTEMPTS attempts"
                    echo "‚ö†Ô∏è WARNING: Using drizzle-kit migrate as fallback - this may cause issues if migrations were partially applied"
                    echo "‚ö†Ô∏è Trying drizzle-kit migrate as fallback..."
                    # Fallback –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –∫–æ–º–∞–Ω–¥—É drizzle-kit migrate
                    # –í–ù–ò–ú–ê–ù–ò–ï: drizzle-kit migrate –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –∫–∞–∫–∏–µ –º–∏–≥—Ä–∞—Ü–∏–∏ —É–∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã
                    if docker exec "$CONTAINER_NAME" npm run db:migrate 2>&1; then
                      MIGRATION_SUCCESS=true
                      echo "‚úÖ Database migrations completed successfully (using drizzle-kit migrate)"
                      break
                    else
                      echo "‚ùå Database migrations failed after $MAX_MIGRATION_ATTEMPTS attempts (both methods)"
                      echo "üìã Container logs:"
                      docker logs "$CONTAINER_NAME" --tail 50 || true
                      exit 1
                    fi
                  fi
                fi
              done
              
              if [ "$MIGRATION_SUCCESS" != true ]; then
                echo "‚ùå Failed to apply database migrations"
                exit 1
              fi
            else
              echo "‚ÑπÔ∏è Database migrations skipped (RUN_MIGRATIONS not set to 'true')"
            fi
            
            # –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö Docker —Ä–µ—Å—É—Ä—Å–æ–≤ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
            echo "üßπ Cleaning up unused Docker resources..."
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1 || true
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || true
            
            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ volumes –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            # –£–¥–∞–ª—è–µ—Ç: –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã, build cache, —Å–µ—Ç–∏
            docker system prune -a -f || echo "‚ö†Ô∏è Warning: Some resources could not be cleaned up"
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1 || true
            
            echo "‚úÖ Deployment completed successfully!"
          REMOTE_SCRIPT
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          PROJECT_DIR_VALUE: ${{ secrets.DEPLOY_PROJECT_PATH }}
          CONTAINER_NAME: ${{ secrets.DEPLOY_CONTAINER_NAME || 'atom-dbro-app' }}
          SERVICE_NAME: ${{ secrets.DEPLOY_SERVICE_NAME || 'app' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          COMPOSE_PROJECT_NAME: ${{ secrets.DEPLOY_COMPOSE_PROJECT_NAME || '' }}
          RUN_MIGRATIONS: ${{ secrets.RUN_MIGRATIONS || 'false' }}

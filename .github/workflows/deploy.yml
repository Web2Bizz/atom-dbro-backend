name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  IMAGE_NAME: ${{ secrets.DEPLOY_IMAGE_NAME || 'atom-dbro-backend' }}

jobs:
  build:
    name: Build and Export Docker Image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      - name: Verify image was built
        run: |
          if ! docker images | grep -q "${{ env.IMAGE_NAME }}.*latest"; then
            echo "‚ùå ERROR: Docker image was not built successfully"
            exit 1
          fi
          echo "‚úÖ Docker image built successfully: ${{ env.IMAGE_NAME }}:latest"
          docker images | grep "${{ env.IMAGE_NAME }}"

      - name: Export Docker image to tar.gz
        run: |
          echo "üì¶ Exporting Docker image to tar.gz..."
          docker save ${{ env.IMAGE_NAME }}:latest | gzip > image.tar.gz
          
          echo "üìä Image file info:"
          ls -lh image.tar.gz
          IMAGE_SIZE=$(du -h image.tar.gz | cut -f1)
          echo "Image size: $IMAGE_SIZE"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω –∏ –Ω–µ –ø—É—Å—Ç–æ–π
          if [ ! -f image.tar.gz ] || [ ! -s image.tar.gz ]; then
            echo "‚ùå ERROR: Failed to export Docker image"
            exit 1
          fi
          
          echo "‚úÖ Docker image exported successfully"

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar.gz
          retention-days: 1

  transfer:
    name: Transfer Image to Server
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Validate SSH connection
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "echo 'SSH connection successful' && hostname"

      - name: Transfer Docker image to server
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          
          echo "üì¶ Transferring Docker image to server..."
          echo "üìä Image file size: $(du -h image.tar.gz | cut -f1)"
          
          # –ü–µ—Ä–µ–¥–∞–µ–º –æ–±—Ä–∞–∑ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
          scp -o StrictHostKeyChecking=no -P "$SSH_PORT" image.tar.gz ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:/tmp/
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "if [ -f /tmp/image.tar.gz ]; then echo '‚úÖ Image file transferred successfully'; ls -lh /tmp/image.tar.gz; else echo '‚ùå ERROR: Image file not found on server'; exit 1; fi"
          
          echo "‚úÖ Docker image transferred successfully"
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}

  deploy:
    name: Deploy Application
    needs: transfer
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Deploy application
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "export PROJECT_DIR_VALUE='$PROJECT_DIR_VALUE' CONTAINER_NAME='$CONTAINER_NAME' IMAGE_NAME='$IMAGE_NAME'; bash -s" << 'REMOTE_SCRIPT'
            set -e
            
            IMAGE_NAME="${IMAGE_NAME:-atom-dbro-backend}"
            PROJECT_DIR="$PROJECT_DIR_VALUE"
            CONTAINER_NAME="${CONTAINER_NAME:-atom-dbro-app}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è PROJECT_DIR —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ùå ERROR: PROJECT_DIR is not set"
              exit 1
            fi
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
            echo "üìÅ Changing to project directory: $PROJECT_DIR"
            cd "$PROJECT_DIR" || {
              echo "‚ùå ERROR: Failed to change to project directory: $PROJECT_DIR"
              exit 1
            }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found in $PROJECT_DIR"
              echo "Current directory: $(pwd)"
              echo "Files in directory:"
              ls -la || true
              exit 1
            fi
            
            echo "‚úÖ Found docker-compose.yml in $(pwd)"
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–∑ –≤ Docker
            echo "üì• Importing Docker image from tar.gz..."
            if [ ! -f /tmp/image.tar.gz ]; then
              echo "‚ùå ERROR: Image file not found: /tmp/image.tar.gz"
              exit 1
            fi
            
            echo "üìä Image file size: $(du -h /tmp/image.tar.gz | cut -f1)"
            docker load -i /tmp/image.tar.gz
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ –∑–∞–≥—Ä—É–∂–µ–Ω
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Failed to import Docker image"
              exit 1
            fi
            
            echo "‚úÖ Docker image imported successfully"
            
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            rm -f /tmp/image.tar.gz
            echo "üßπ Cleaned up temporary image file"
            
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º
            echo "üßπ Removing old image versions (if any)..."
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || echo "No old image versions to remove"
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ç–µ–π Docker (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
            echo "üåê Ensuring Docker networks exist..."
            docker network create atom-external-network 2>/dev/null || echo "Network atom-external-network already exists"
            docker network create atom-internal-network 2>/dev/null || echo "Network atom-internal-network already exists"
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            echo "üîÑ Restarting application container with new image..."
            echo "Working directory: $(pwd)"
            echo "Container name: $CONTAINER_NAME"
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
            docker stop "$CONTAINER_NAME" 2>/dev/null || echo "Container $CONTAINER_NAME is not running"
            docker rm "$CONTAINER_NAME" 2>/dev/null || echo "Container $CONTAINER_NAME does not exist"
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–µ—Ä–≤–∏—Å app —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º (–±–µ–∑ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π)
            docker compose -f "$PROJECT_DIR/docker-compose.yml" up -d --no-deps app
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            echo "‚è≥ Waiting for application container to be ready..."
            MAX_CONTAINER_WAIT_ATTEMPTS=30
            CONTAINER_WAIT_ATTEMPT=0
            CONTAINER_READY=false
            
            while [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
              if docker ps | grep -q "$CONTAINER_NAME" && docker exec "$CONTAINER_NAME" echo "Container is ready" > /dev/null 2>&1; then
                CONTAINER_READY=true
                echo "‚úÖ Container is ready and accepting commands"
                break
              fi
              CONTAINER_WAIT_ATTEMPT=$((CONTAINER_WAIT_ATTEMPT + 1))
              if [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; then
                echo "Waiting for container to be ready... ($CONTAINER_WAIT_ATTEMPT/$MAX_CONTAINER_WAIT_ATTEMPTS)"
                sleep 2
              fi
            done
            
            if [ "$CONTAINER_READY" != true ]; then
              echo "‚ùå Application container failed to start or is not ready"
              echo "üìã Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              echo "üìã Container logs:"
              docker logs "$CONTAINER_NAME" --tail 50 || true
              exit 1
            fi
            
            # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            echo "üóÑÔ∏è Running database migrations..."
            MAX_MIGRATION_ATTEMPTS=3
            MIGRATION_ATTEMPT=0
            
            while [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; do
              echo "Migration attempt $((MIGRATION_ATTEMPT + 1))/$MAX_MIGRATION_ATTEMPTS"
              if docker exec "$CONTAINER_NAME" npm run db:migrate; then
                echo "‚úÖ Database migrations completed successfully"
                break
              else
                MIGRATION_ATTEMPT=$((MIGRATION_ATTEMPT + 1))
                if [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; then
                  echo "‚ö†Ô∏è Migration attempt $MIGRATION_ATTEMPT failed, retrying in 5 seconds..."
                  sleep 5
                else
                  echo "‚ùå Database migrations failed after $MAX_MIGRATION_ATTEMPTS attempts"
                  echo "üìã Container logs:"
                  docker logs "$CONTAINER_NAME" --tail 50
                  exit 1
                fi
              fi
            done
            
            # Health check –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
            echo "üè• Performing health check..."
            MAX_HEALTH_CHECK_ATTEMPTS=30
            HEALTH_CHECK_ATTEMPT=0
            HEALTH_CHECK_SUCCESS=false
            
            while [ $HEALTH_CHECK_ATTEMPT -lt $MAX_HEALTH_CHECK_ATTEMPTS ]; do
              if curl -f http://localhost:3000/api > /dev/null 2>&1; then
                HEALTH_CHECK_SUCCESS=true
                break
              fi
              HEALTH_CHECK_ATTEMPT=$((HEALTH_CHECK_ATTEMPT + 1))
              if [ $HEALTH_CHECK_ATTEMPT -lt $MAX_HEALTH_CHECK_ATTEMPTS ]; then
                echo "Health check attempt $HEALTH_CHECK_ATTEMPT/$MAX_HEALTH_CHECK_ATTEMPTS failed, retrying in 2 seconds..."
                sleep 2
              fi
            done
            
            if [ "$HEALTH_CHECK_SUCCESS" = true ]; then
              echo "‚úÖ Application is healthy and responding!"
              echo "üåê Application is available at: http://localhost:3000"
              echo "üìö Swagger docs: http://localhost:3000/api"
            else
              echo "‚ùå Health check failed after $MAX_HEALTH_CHECK_ATTEMPTS attempts"
              docker logs "$CONTAINER_NAME" --tail 100
              exit 1
            fi
            
            # –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö Docker —Ä–µ—Å—É—Ä—Å–æ–≤ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
            echo "üßπ Cleaning up unused Docker resources..."
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1 || true
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || true
            
            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ volumes –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            # –£–¥–∞–ª—è–µ—Ç: –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã, build cache, —Å–µ—Ç–∏
            docker system prune -a -f || echo "‚ö†Ô∏è Warning: Some resources could not be cleaned up"
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1 || true
            
            echo "‚úÖ Deployment completed successfully!"
          REMOTE_SCRIPT
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          PROJECT_DIR_VALUE: ${{ secrets.DEPLOY_PROJECT_PATH }}
          CONTAINER_NAME: ${{ secrets.DEPLOY_CONTAINER_NAME || 'atom-dbro-app' }}
